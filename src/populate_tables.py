
import hashlib
import random
import string

import sqlalchemy
import os
import dotenv
from faker import Faker
import numpy as np
import passlib

from src.api.discovery import PreferenceType
from src.api.song import Genre, ContentType, FeedbackType, Mood
from src.api.user import user_role
from src.fake_data_constants import fake_album_names, fake_song_names, fake_comments, fake_playlist_titles


def database_connection_url():
    return "postgresql://postgres:postgres@localhost:54322/postgres"

engine = sqlalchemy.create_engine(database_connection_url(), use_insertmanyvalues=True)

with engine.begin() as conn:
    drop_tables = """
                    DROP TABLE IF EXISTS albums CASCADE;
                    DROP TABLE IF EXISTS comments;
                    DROP TABLE IF EXISTS feedback;
                    DROP TABLE IF EXISTS mood_songs;
                    DROP TABLE IF EXISTS playlist_songs;
                    DROP TABLE IF EXISTS playlists CASCADE;
                    DROP TABLE IF EXISTS songs CASCADE;
                    DROP TABLE IF EXISTS user_preferences;
                    DROP TABLE IF EXISTS users CASCADE;
                    """
    drop_types = """
                    DROP TYPE IF EXISTS content_type;
                    DROP TYPE IF EXISTS feedback_type;
                    DROP TYPE IF EXISTS genre;
                    DROP TYPE IF EXISTS mood;
                    DROP TYPE IF EXISTS preference_type;
                    DROP TYPE IF EXISTS user_role;
                    """
    create_types = """
                    CREATE TYPE content_type AS ENUM ('album', 'song');
                    CREATE TYPE feedback_type AS ENUM ('sound quality', 'lyrics', 'vocals', 'melody', 'originality', 'overall');
                    CREATE TYPE genre AS ENUM ('Jazz', 'Blues', 'RnB', 'Hip Hop', 'Country', 'Pop', 'Rock', 'Classical', 'Reggae', 'Folk', 'EDM', 'Indie', 'Metal', 'Soundtrack');
                    CREATE TYPE mood AS ENUM ('happy', 'sad', 'nostalgic', 'relaxing', 'energetic', 'angry', 'uplifting', 'calm', 'motivational', 'experimental');
                    CREATE TYPE preference_type AS ENUM ('genre', 'mood');
                    CREATE TYPE user_role AS ENUM ('artist', 'listener', 'listener_and_artist');
                    """

    create_tables = """
            create table
  public.users (
    id bigint generated by default as identity,
    created_at timestamp with time zone not null default now(),
    email text null,
    password text not null,
    name text not null,
    user_type public.user_role not null,
    username text not null,
    salt text null,
    spotlight boolean not null default false,
    description text null,
    constraint users_pkey1 primary key (id),
    constraint users_email_key unique (email),
    constraint users_username_key unique (username)
  ) tablespace pg_default;
            
            create table
  public.albums (
    id bigint generated by default as identity,
    created_at timestamp with time zone not null default now(),
    title text not null,
    genre public.genre not null,
    artist_id bigint not null,
    release_date date not null default now(),
    constraint albums_pkey primary key (id),
    constraint albums_artist_id_fkey foreign key (artist_id) references users (id) on delete cascade
  ) tablespace pg_default;
  
  
            create table
  public.songs (
    id bigint generated by default as identity,
    created_at timestamp with time zone not null default now(),
    title text not null,
    genre public.genre not null,
    duration integer not null,
    album_id bigint null,
    artist_id bigint not null,
    release_date date not null default now(),
    constraint songs_pkey primary key (id),
    constraint songs_album_id_fkey foreign key (album_id) references albums (id) on delete cascade,
    constraint songs_artist_id_fkey foreign key (artist_id) references users (id) on delete cascade,
    constraint songs_duration_check check ((duration > 0))
  ) tablespace pg_default;
  
            create table
  public.comments (
    id bigint generated by default as identity,
    created_at timestamp with time zone not null default now(),
    type public.content_type not null,
    comment text not null,
    user_id bigint not null,
    song_id bigint null,
    album_id bigint null,
    constraint Comments_pkey primary key (id),
    constraint comments_album_id_fkey foreign key (album_id) references albums (id) on delete cascade,
    constraint comments_song_id_fkey foreign key (song_id) references songs (id) on delete cascade,
    constraint comments_user_id_fkey foreign key (user_id) references users (id) on delete cascade
  ) tablespace pg_default;
  
            create table
  public.feedback (
    id bigint generated by default as identity,
    created_at timestamp with time zone not null default now(),
    rating real not null,
    feedback_type public.feedback_type not null,
    user_id bigint not null,
    song_id bigint null,
    album_id bigint null,
    constraint feedback_pkey primary key (id),
    constraint feedback_album_id_fkey foreign key (album_id) references albums (id) on delete cascade,
    constraint feedback_song_id_fkey foreign key (song_id) references songs (id) on delete cascade,
    constraint feedback_user_id_fkey foreign key (user_id) references users (id) on delete cascade,
    constraint feedback_rating_check check (
      (
        (rating >= (0)::double precision)
        and (rating <= (5)::double precision)
      )
    )
  ) tablespace pg_default;
  
            create table
  public.mood_songs (
    created_at timestamp with time zone not null default now(),
    mood public.mood not null,
    song bigint not null,
    constraint mood_songs_pkey primary key (mood, song),
    constraint mood_songs_song_fkey foreign key (song) references songs (id) on delete cascade
  ) tablespace pg_default;
  
            create table
  public.playlists (
    id bigint generated by default as identity,
    created_at timestamp with time zone not null default now(),
    creator_id bigint not null,
    title text not null,
    mood public.mood not null,
    constraint playlists_pkey primary key (id),
    constraint playlists_creator_id_fkey foreign key (creator_id) references users (id) on delete cascade
  ) tablespace pg_default;
  
            create table
  public.playlist_songs (
    id bigint generated by default as identity,
    created_at timestamp with time zone not null default now(),
    playlist_id bigint not null,
    song_id bigint not null,
    constraint playlist_songs_pkey primary key (id),
    constraint playlist_songs_playlist_id_fkey foreign key (playlist_id) references playlists (id) on delete cascade,
    constraint playlist_songs_song_id_fkey foreign key (song_id) references songs (id) on delete cascade
  ) tablespace pg_default;
  
            create table
  public.user_preferences (
    id bigint generated by default as identity,
    created_at timestamp with time zone not null default now(),
    user_id integer not null,
    preference text not null,
    preference_type public.preference_type not null,
    constraint user_preferences_pkey primary key (id)
  ) tablespace pg_default;"""

    conn.execute(sqlalchemy.text(drop_tables))
    conn.execute(sqlalchemy.text(drop_types))
    conn.execute(sqlalchemy.text(create_types))
    conn.execute(sqlalchemy.text(create_tables))

def generate_random_password(length=12):
    characters = string.ascii_letters + string.digits + string.punctuation
    password = ''.join(random.choice(characters) for _ in range(length))
    return password

print("Populating users...")
#populate users
with engine.begin() as conn:
    num_users = 1376
    fake = Faker()
    user_type_distribution = np.random.choice([user_role.artist.value, user_role.listener.value, user_role.listener_and_artist.value], num_users, p=[0.3, 0.6, 0.1])
    usernames = []
    emails = []
    for i in range(num_users):
        profile = fake.profile()
        email = profile['mail']
        if email in emails:
            email = email.split('@')
            email = f"{email[0]}{i}{email[1]}"
        emails.append(email)
        unencrypted_password = generate_random_password()
        name = profile['name']
        user_type = user_type_distribution[i].item()
        username = ''.join(name.split()).lower()
        if username in usernames:
            username = username + str(i)
        usernames.append(username)
        #salt = crypt.mksalt(method=crypt.METHOD_MD5)
        salt = os.urandom(16)
        #encrypted_password = crypt.crypt(unencrypted_password, salt=salt)
        hasher = hashlib.md5()
        hasher.update(salt)
        hasher.update(unencrypted_password.encode('utf-8'))
        encrypted_password = hasher.hexdigest()
        if user_type == 'listener':
            spotlight = "False"
        else:
            spotlight = np.random.choice(["True", "False"], p=[0.5, 0.5])
        insert = """
                    INSERT INTO users (email, password, name, user_type, username, salt, spotlight)
                    VALUES (:e, :p, :n, :ut, :un, :s, :sl)"""
        conn.execute(sqlalchemy.text(insert), {"e": email, "p": encrypted_password, "n": name, "ut": user_type, "un": username, "s": salt, "sl": spotlight})
        if i % 100 == 0:
            print("username = " + username + ", password = " + unencrypted_password)

print("Populating albums...")
#populate albums
with engine.begin() as conn:
    num_albums = 12
    genre_list = [genre.value for genre in Genre]
    for i in range(num_albums):
        title = fake_album_names[i]
        genre = np.random.choice(genre_list)
        artist = conn.execute(sqlalchemy.text(f"SELECT id FROM users WHERE user_type != '{user_role.listener.value}' ORDER BY RANDOM() LIMIT 1")).scalar()
        release_date = fake.date_between(start_date='-50y', end_date='today')
        insert = """INSERT INTO albums (title, genre, artist_id, release_date) VALUES (:t, :g, :aid, :rd)"""
        conn.execute(sqlalchemy.text(insert), {"t": title, "g": genre, "aid": artist, "rd": release_date})

print("Populating songs...")
#populate songs
with engine.begin() as conn:
    num_songs = 240
    for i in range(num_songs):
        title = np.random.choice(fake_song_names)
        genre = np.random.choice(genre_list)
        duration = max(np.random.normal(loc=234, scale=66), 10)
        (album_id, artist_id, album_genre, album_release_date) = conn.execute(sqlalchemy.text("SELECT id, artist_id, genre, release_date FROM albums ORDER BY RANDOM() LIMIT 1")).first()
        if np.random.choice([True, False], p=[0.9, 0.1]):
            #single
            artist = conn.execute(sqlalchemy.text(
                f"SELECT id FROM users WHERE user_type != '{user_role.listener.value}' ORDER BY RANDOM() LIMIT 1")).scalar()
            release_date = fake.date_between(start_date='-50y', end_date='today')
            insert = """INSERT INTO songs (title, genre, duration, artist_id, release_date) VALUES (:t, :g, :d, :aid, :rd)"""
            conn.execute(sqlalchemy.text(insert), {"t": title, "g": genre, "d": duration, "aid": artist, "rd": release_date})
        else:
            #on an album
            insert = """INSERT INTO songs (title, genre, duration, album_id, artist_id, release_date) VALUES (:t, :g, :d, :alid, :aid, :rd)"""
            conn.execute(sqlalchemy.text(insert),
                         {"t": title, "g": album_genre, "d": duration, "alid": album_id, "aid": artist_id, "rd": album_release_date})

content_types = [ct.value for ct in ContentType]
print("Populating comments...")
#populate comments
with engine.begin() as conn:
    num_comments = 1257
    for i in range(num_comments):
        comment = np.random.choice(fake_comments)
        content_type = np.random.choice(content_types)
        user = conn.execute(sqlalchemy.text(f"SELECT id FROM users WHERE user_type != '{user_role.artist.value}' ORDER BY RANDOM() LIMIT 1")).scalar()
        if content_type == 'album':
            album_id = conn.execute(sqlalchemy.text("SELECT id FROM albums ORDER BY RANDOM() LIMIT 1")).scalar()
            insert = """INSERT INTO comments (type, comment, user_id, album_id) VALUES (:t, :c, :uid, :aid)"""
            conn.execute(sqlalchemy.text(insert), {"t": content_type, "c": comment, "uid": user, "aid": album_id})
        else:
            song_id = conn.execute(sqlalchemy.text("SELECT id FROM songs ORDER BY RANDOM() LIMIT 1")).scalar()
            insert = """INSERT INTO comments (type, comment, user_id, song_id) VALUES (:t, :c, :uid, :sid)"""
            conn.execute(sqlalchemy.text(insert), {"t": content_type, "c": comment, "uid": user, "sid": song_id})

feedback_types = [ft.value for ft in FeedbackType]
print("Populating feedback...")
#populate feedback
with engine.begin() as conn:
    num_ratings = 25148
    for i in range(num_ratings):
        rating = np.random.randint(1, 6)
        content_type = np.random.choice(content_types)
        feedback_type = np.random.choice(feedback_types)
        user = conn.execute(sqlalchemy.text(f"SELECT id FROM users WHERE user_type != '{user_role.artist.value}' ORDER BY RANDOM() LIMIT 1")).scalar()
        if content_type == 'album':
            album_id = conn.execute(sqlalchemy.text("SELECT id FROM albums ORDER BY RANDOM() LIMIT 1")).scalar()
            insert = """INSERT INTO feedback (rating, feedback_type, user_id, album_id) VALUES (:r, :f, :uid, :aid)"""
            conn.execute(sqlalchemy.text(insert), {"r": rating, "f": feedback_type, "uid": user, "aid": album_id})
        else:
            song_id = conn.execute(sqlalchemy.text("SELECT id FROM songs ORDER BY RANDOM() LIMIT 1")).scalar()
            insert = """INSERT INTO feedback (rating, feedback_type, user_id, song_id) VALUES (:r, :f, :uid, :sid)"""
            conn.execute(sqlalchemy.text(insert), {"r": rating, "f": feedback_type, "uid": user, "sid": song_id})


#populate mood_songs
print("Populating mood_songs...")
moods = [m.value for m in Mood]
used_pairs = []
with engine.begin() as conn:
    num_rows = 240
    while i < num_rows:
        mood = np.random.choice(moods)
        song_id = conn.execute(sqlalchemy.text("SELECT id FROM songs ORDER BY RANDOM() LIMIT 1")).scalar()
        if (mood, song_id) not in used_pairs:
            insert = """INSERT INTO mood_songs (mood, song) VALUES (:m, :s)"""
            conn.execute(sqlalchemy.text(insert), {"m": mood, "s": song_id})
            i += 1
        used_pairs.append((mood, song_id))

#populate playlists
print("Populating playlists...")
with engine.begin() as conn:
    num_playlists = 9580
    existing_titles = []
    for i in range(num_playlists):
        creator = conn.execute(sqlalchemy.text(f"SELECT id FROM users WHERE user_type != '{user_role.artist.value}' ORDER BY RANDOM() LIMIT 1")).scalar()
        title = np.random.choice(fake_playlist_titles)
        if title in existing_titles:
            title = title + str(i)
        existing_titles.append(title)
        mood = np.random.choice(moods)
        insert = """INSERT INTO playlists (creator_id, title, mood) VALUES (:cid, :t, :m)"""
        conn.execute(sqlalchemy.text(insert), {"cid": creator, "t": title, "m": mood})

#populate playlist_songs
print("Populating playlist_songs...")
with engine.begin() as conn:
    num_rows = 958024
    for i in range(num_rows):
        pid = conn.execute(sqlalchemy.text(f"SELECT id FROM playlists ORDER BY RANDOM() LIMIT 1")).scalar()
        sid = conn.execute(sqlalchemy.text(f"SELECT id FROM songs ORDER BY RANDOM() LIMIT 1")).scalar()
        insert = """INSERT INTO playlist_songs (playlist_id, song_id) VALUES (:p, :s)"""
        conn.execute(sqlalchemy.text(insert), {"p": pid, "s": sid})

#populate user_preferences
print("Populating user_preferences...")
pref_types = [pt.value for pt in PreferenceType]
with engine.begin() as conn:
    num_rows = 4124
    for i in range(num_rows):
        user_id = conn.execute(sqlalchemy.text(f"SELECT id FROM users WHERE user_type != '{user_role.artist.value}' ORDER BY RANDOM() LIMIT 1")).scalar()
        pref_type = np.random.choice(pref_types)
        if pref_type == 'genre':
            pref = np.random.choice(genre_list)
        else:
            pref = np.random.choice(moods)
        insert = """INSERT INTO user_preferences (user_id, preference, preference_type) VALUES (:uid, :p, :pt)"""
        conn.execute(sqlalchemy.text(insert), {"uid": user_id, "p": pref, "pt": pref_type})