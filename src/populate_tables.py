
import hashlib
import random
import string

import sqlalchemy
import os
import dotenv
from faker import Faker
import numpy as np
import passlib

from src.api.user import user_role


def database_connection_url():
    return "postgresql://postgres:postgres@localhost:54322/postgres"

engine = sqlalchemy.create_engine(database_connection_url(), use_insertmanyvalues=True)

with engine.begin() as conn:
    drop_tables = """
                    DROP TABLE IF EXISTS albums CASCADE;
                    DROP TABLE IF EXISTS comments;
                    DROP TABLE IF EXISTS feedback;
                    DROP TABLE IF EXISTS mood_songs;
                    DROP TABLE IF EXISTS playlist_songs;
                    DROP TABLE IF EXISTS playlists CASCADE;
                    DROP TABLE IF EXISTS songs CASCADE;
                    DROP TABLE IF EXISTS user_preferences;
                    DROP TABLE IF EXISTS users CASCADE;
                    """
    drop_types = """
                    DROP TYPE IF EXISTS content_type;
                    DROP TYPE IF EXISTS feedback_type;
                    DROP TYPE IF EXISTS genre;
                    DROP TYPE IF EXISTS mood;
                    DROP TYPE IF EXISTS preference_type;
                    DROP TYPE IF EXISTS user_role;
                    """
    create_types = """
                    CREATE TYPE content_type AS ENUM ('album', 'song');
                    CREATE TYPE feedback_type AS ENUM ('sound quality', 'lyrics', 'vocals', 'melody', 'originality', 'overall');
                    CREATE TYPE genre AS ENUM ('Jazz', 'Blues', 'RnB', 'Hip Hop', 'Country', 'Pop', 'Rock', 'Classical', 'Reggae', 'Folk', 'EDM', 'Indie', 'Metal', 'Soundtrack');
                    CREATE TYPE mood AS ENUM ('happy', 'sad', 'nostalgic', 'relaxing', 'energetic', 'angry', 'uplifting', 'calm', 'motivational', 'experimental');
                    CREATE TYPE preference_type AS ENUM ('genre', 'mood');
                    CREATE TYPE user_role AS ENUM ('artist', 'listener', 'listener_and_artist');
                    """

    create_tables = """
            create table
  public.users (
    id bigint generated by default as identity,
    created_at timestamp with time zone not null default now(),
    email text null,
    password text not null,
    name text not null,
    user_type public.user_role not null,
    username text not null,
    salt text null,
    spotlight boolean not null default false,
    description text null,
    constraint users_pkey1 primary key (id),
    constraint users_email_key unique (email),
    constraint users_username_key unique (username)
  ) tablespace pg_default;
            
            create table
  public.albums (
    id bigint generated by default as identity,
    created_at timestamp with time zone not null default now(),
    title text not null,
    genre public.genre not null,
    artist_id bigint not null,
    release_date date not null default now(),
    constraint albums_pkey primary key (id),
    constraint albums_artist_id_fkey foreign key (artist_id) references users (id) on delete cascade
  ) tablespace pg_default;
  
  
            create table
  public.songs (
    id bigint generated by default as identity,
    created_at timestamp with time zone not null default now(),
    title text not null,
    genre public.genre not null,
    duration integer not null,
    album_id bigint null,
    artist_id bigint not null,
    release_date date not null default now(),
    constraint songs_pkey primary key (id),
    constraint songs_album_id_fkey foreign key (album_id) references albums (id) on delete cascade,
    constraint songs_artist_id_fkey foreign key (artist_id) references users (id) on delete cascade,
    constraint songs_duration_check check ((duration > 0))
  ) tablespace pg_default;
  
            create table
  public.comments (
    id bigint generated by default as identity,
    created_at timestamp with time zone not null default now(),
    type public.content_type not null,
    comment text not null,
    user_id bigint not null,
    song_id bigint null,
    album_id bigint null,
    constraint Comments_pkey primary key (id),
    constraint comments_album_id_fkey foreign key (album_id) references albums (id) on delete cascade,
    constraint comments_song_id_fkey foreign key (song_id) references songs (id) on delete cascade,
    constraint comments_user_id_fkey foreign key (user_id) references users (id) on delete cascade
  ) tablespace pg_default;
  
            create table
  public.feedback (
    id bigint generated by default as identity,
    created_at timestamp with time zone not null default now(),
    rating real not null,
    feedback_type public.feedback_type not null,
    user_id bigint not null,
    song_id bigint null,
    album_id bigint null,
    constraint feedback_pkey primary key (id),
    constraint feedback_album_id_fkey foreign key (album_id) references albums (id) on delete cascade,
    constraint feedback_song_id_fkey foreign key (song_id) references songs (id) on delete cascade,
    constraint feedback_user_id_fkey foreign key (user_id) references users (id) on delete cascade,
    constraint feedback_rating_check check (
      (
        (rating >= (0)::double precision)
        and (rating <= (5)::double precision)
      )
    )
  ) tablespace pg_default;
  
            create table
  public.mood_songs (
    created_at timestamp with time zone not null default now(),
    mood public.mood not null,
    song bigint not null,
    constraint mood_songs_pkey primary key (mood, song),
    constraint mood_songs_song_fkey foreign key (song) references songs (id) on delete cascade
  ) tablespace pg_default;
  
            create table
  public.playlists (
    id bigint generated by default as identity,
    created_at timestamp with time zone not null default now(),
    creator_id bigint not null,
    title text not null,
    mood public.mood not null,
    constraint playlists_pkey primary key (id),
    constraint playlists_creator_id_fkey foreign key (creator_id) references users (id) on delete cascade
  ) tablespace pg_default;
  
            create table
  public.playlist_songs (
    id bigint generated by default as identity,
    created_at timestamp with time zone not null default now(),
    playlist_id bigint not null,
    song_id bigint not null,
    constraint playlist_songs_pkey primary key (id),
    constraint playlist_songs_playlist_id_fkey foreign key (playlist_id) references playlists (id) on delete cascade,
    constraint playlist_songs_song_id_fkey foreign key (song_id) references songs (id) on delete cascade
  ) tablespace pg_default;
  
            create table
  public.user_preferences (
    id bigint generated by default as identity,
    created_at timestamp with time zone not null default now(),
    user_id integer not null,
    preference text not null,
    preference_type public.preference_type not null,
    constraint user_preferences_pkey primary key (id)
  ) tablespace pg_default;"""

    conn.execute(sqlalchemy.text(drop_tables))
    conn.execute(sqlalchemy.text(drop_types))
    conn.execute(sqlalchemy.text(create_types))
    conn.execute(sqlalchemy.text(create_tables))

def generate_random_password(length=12):
    characters = string.ascii_letters + string.digits + string.punctuation
    password = ''.join(random.choice(characters) for _ in range(length))
    return password

#populate users
with engine.begin() as conn:
    num_users = 1376
    fake = Faker()
    user_type_distribution = np.random.choice([user_role.artist.value, user_role.listener.value, user_role.listener_and_artist.value], num_users, p=[0.3, 0.6, 0.1])
    usernames = []
    emails = []
    for i in range(num_users):
        profile = fake.profile()
        email = profile['mail']
        if email in emails:
            email = email.split('@')
            email = f"{email[0]}{i}{email[1]}"
        emails.append(email)
        unencrypted_password = generate_random_password()
        name = profile['name']
        user_type = user_type_distribution[i].item()
        username = ''.join(name.split()).lower()
        if username in usernames:
            username = username + str(i)
        usernames.append(username)
        #salt = crypt.mksalt(method=crypt.METHOD_MD5)
        salt = os.urandom(16)
        #encrypted_password = crypt.crypt(unencrypted_password, salt=salt)
        hasher = hashlib.md5()
        hasher.update(salt)
        hasher.update(unencrypted_password.encode('utf-8'))
        encrypted_password = hasher.hexdigest()
        if user_type == 'listener':
            spotlight = "False"
        else:
            spotlight = np.random.choice(["True", "False"], p=[0.5, 0.5])
        insert = """
                    INSERT INTO users (email, password, name, user_type, username, salt, spotlight)
                    VALUES (:e, :p, :n, :ut, :un, :s, :sl)"""
        conn.execute(sqlalchemy.text(insert), {"e": email, "p": encrypted_password, "n": name, "ut": user_type, "un": username, "s": salt, "sl": spotlight})
        if i % 100 == 0:
            print("username = " + username + ", password = " + unencrypted_password)
